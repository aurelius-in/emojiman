function enemyBehavior(enemy) {
  const currentTime = Date.now();

  if (!enemy.smarterTime) {
    const emojiIndex = enemyEmojis.indexOf(enemy.emoji);
    enemy.smarterTime = currentTime + (emojiIndex + 1 + 3) * 1000; // 1-based index + 3 seconds, converted to milliseconds
  }

  if (currentTime - enemy.lastMove < 500) return;

  // Relocate emoji if smarterTime is reached while still in spawn area
  if (currentTime > enemy.smarterTime && !enemy.hasLeftSpawn) {
    enemy.x = 7 * cellSize + cellSize / 2;
    enemy.y = enemy.y < canvas.height / 2 ? 6 * cellSize + cellSize / 2 : 18 * cellSize + cellSize / 2;
    enemy.hasLeftSpawn = true;
    enemy.direction = 'up'; // Set an initial intelligent direction
  }

  let nextX = enemy.x;
  let nextY = enemy.y;

  if (enemy.direction === 'up') nextY -= cellSize;
  if (enemy.direction === 'down') nextY += cellSize;
  if (enemy.direction === 'left') nextX -= cellSize;
  if (enemy.direction === 'right') nextX += cellSize;

  const nextGridX = Math.floor(nextX / cellSize);
  const nextGridY = Math.floor(nextY / cellSize);

  if (!enemy.hasLeftSpawn && maze[nextGridY][nextGridX] === '2') {
    enemy.direction = enemy.y < canvas.height / 2 ? 'up' : 'down';
  }

  if (enemy.hasLeftSpawn && maze[nextGridY][nextGridX] === '2') {
    return;
  }

  if (maze[nextGridY][nextGridX] !== '1' || currentTime > enemy.smarterTime) {
    enemy.x = nextX;
    enemy.y = nextY;
    enemy.lastMove = currentTime;
    enemy.hasLeftSpawn = true;
  }

  let dx = pacmanX - enemy.x;
  let dy = pacmanY - enemy.y;
  let randomFactor = currentTime < enemy.smarterTime ? Math.random() < 0.2 : Math.random() < 0.1;

  const possibleDirections = ['up', 'down', 'left', 'right'].filter(dir => {
    let testX = enemy.x, testY = enemy.y;
    if (dir === 'up') testY -= cellSize;
    if (dir === 'down') testY += cellSize;
    if (dir === 'left') testX -= cellSize;
    if (dir === 'right') testX += cellSize;
    const testGridX = Math.floor(testX / cellSize);
    const testGridY = Math.floor(testY / cellSize);
    return maze[testGridY][testGridX] !== '1';
  });

  if (currentTime > enemy.smarterTime || randomFactor || possibleDirections.length === 0) {
    if (Math.abs(dx) > Math.abs(dy)) {
      enemy.direction = dx > 0 ? 'right' : 'left';
    } else {
      enemy.direction = dy > 0 ? 'down' : 'up';
    }
    if (!possibleDirections.includes(enemy.direction)) {
      enemy.direction = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
    }
  }

  enemy.lastX = enemy.x;
  enemy.lastY = enemy.y;
}
