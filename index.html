<!DOCTYPE html>
<html>
<head>
  <title>Pac-Man</title>
  <link rel="stylesheet" type="text/css" href="style.css">
  <script src="script.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body oncontextmenu="return false;">
  <div id="lives">üòÉüòÉüòÉ</div>
  <div id="score" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 30px; font-family: 'Press Start 2P', cursive;"></div>
  <canvas id="gameCanvas" width="964" height="1533"></canvas>

<div id="joystick">
  <div id="joystick-row1">
<button id="up" class="joystick-button">üîº
</button>
  </div>
  <div id="joystick-row2">
    <button id="left" class="joystick-button">‚óÄÔ∏è
</button>
    <div id="joystick-space"></div>
    <button id="right" class="joystick-button">‚ñ∂Ô∏è
</button>
  </div>
  <div id="joystick-row3">
    <button id="down" class="joystick-button">üîΩ</button>
  </div>
</div>

<script>




  function checkCollision(x, y, radius, isEnemy = false) {
    const corners = [
      { x: x - radius, y: y - radius },
      { x: x + radius, y: y - radius },
      { x: x - radius, y: y + radius },
      { x: x + radius, y: y + radius }
    ];

    return corners.some(corner => {
      const gridX = Math.floor(corner.x / cellSize);
      const gridY = Math.floor(corner.y / cellSize);
      return maze[gridY][gridX] === '1' || (maze[gridY][gridX] === '2' && !isEnemy);
    });
  }

  function drawMaze() {
    for (let y = 0; y < maze.length; y++) {
      for (let x = 0; x < maze[y].length; x++) {
        const cell = maze[y][x];
        const xPos = x * cellSize;
        const yPos = y * cellSize;
        if (cell === '1') {
          ctx.fillStyle = '#0000FF';
          ctx.fillRect(xPos, yPos, cellSize, cellSize);
        } else if (cell === '2') {
          ctx.fillStyle = '#808080';
          ctx.fillRect(xPos, yPos, cellSize, cellSize);
        } else if (cell === '3') {
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(xPos + cellSize / 2, yPos + cellSize / 2, 5.5, 0, Math.PI * 2);
          ctx.fill();
        } else if (cell === '4') {
          ctx.fillStyle = '#FFFFFF';
          ctx.beginPath();
          ctx.arc(xPos + cellSize / 2, yPos + cellSize / 2, 11, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Center Pac-Man when turning
  function centerPacmanOnGrid() {
    const gridX = Math.floor(pacmanX / cellSize);
    const gridY = Math.floor(pacmanY / cellSize);

    pacmanX = (gridX * cellSize) + cellSize / 2;
    pacmanY = (gridY * cellSize) + cellSize / 2;
  }

function checkCherryCollision() {
  if (cherry) {
    const dx = pacmanX - cherry.x;
    const dy = pacmanY - cherry.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < pacmanRadius * 2) {
      score += 1000;
      scoreElement.textContent = 'Score: ' + score;
      cherry = null;
    }
  }
}
  
function drawCherry() {
  if (cherry) {
    ctx.font = `${pacmanRadius * 2.3}px Arial`;
    ctx.fillText('üçí', cherry.x - pacmanRadius, cherry.y + pacmanRadius);
  }
}
  
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawMaze();

if (isPowerMode) {
    ctx.fillStyle = colors[colorIndex];
    enemies.forEach((enemy, index) => {
      drawEmojiPower(ctx, enemy, index);
      emojiPowerBehavior(enemy);
    });
    checkEnemyCollision();
  } else {
    ctx.fillStyle = '#FFFF00';
    enemies.forEach(enemy => {
      drawEnemy(enemy);
      enemyBehavior(enemy);
    });
  }

  if (direction === 'up') angle = -Math.PI / 2;
  if (direction === 'down') angle = Math.PI / 2;
  if (direction === 'left') angle = Math.PI;
  if (direction === 'right') angle = 0;

  ctx.fillStyle = '#FFFF00';
  ctx.beginPath();
  ctx.moveTo(pacmanX, pacmanY);
  ctx.arc(pacmanX, pacmanY, pacmanRadius, angle + mouthAngle, angle + Math.PI * 2 - mouthAngle);
  ctx.lineTo(pacmanX, pacmanY);
  ctx.fill();

  let nextX = pacmanX;
  let nextY = pacmanY;

  if (direction === 'up') nextY -= pacmanSpeed;
  if (direction === 'down') nextY += pacmanSpeed;
  if (direction === 'left') nextX -= pacmanSpeed;
  if (direction === 'right') nextX += pacmanSpeed;

  // Logic to make Pac-Man reappear on the opposite side
  const middleRowY = 12 * cellSize + (cellSize / 2); // Middle row Y-coordinate
  if (Math.abs(pacmanY - middleRowY) < 1) {
    if (nextX < 0) {
      nextX = canvas.width;
    } else if (nextX > canvas.width) {
      nextX = 0;
    }
  }

  if (!checkCollision(nextX, nextY, pacmanRadius)) {
    pacmanX = nextX;
    pacmanY = nextY;
  } else {
    centerPacmanOnGrid();
  }

  mouthAngle += mouthSpeed;
  if (mouthAngle > Math.PI / 4 || mouthAngle < 0) {
    mouthSpeed = -mouthSpeed;
  }
  
  checkPelletCollision();
  requestAnimationFrame(gameLoop);
  drawCherry();
  checkCherryCollision();
}

document.getElementById('up').addEventListener('click', () => {
  event.preventDefault();
  direction = 'up';
});

document.getElementById('down').addEventListener('click', () => {
  event.preventDefault();
  direction = 'down';
});

document.getElementById('left').addEventListener('click', () => {
  event.preventDefault();
  direction = 'left';
});

document.getElementById('right').addEventListener('click', () => {
 event.preventDefault();
  direction = 'right';
  
});

document.getElementById('up').addEventListener('touchstart', (event) => {
  event.preventDefault();
  direction = 'up';
});

document.getElementById('down').addEventListener('touchstart', (event) => {
  event.preventDefault();
  direction = 'down';
});

document.getElementById('left').addEventListener('touchstart', (event) => {
  event.preventDefault();
  direction = 'left';
});

document.getElementById('right').addEventListener('touchstart', (event) => {
  event.preventDefault();
  direction = 'right';
});


document.addEventListener('keydown', function(event) {
  switch (event.key) {
    case 'ArrowUp':
      direction = 'up';
      break;
    case 'ArrowDown':
      direction = 'down';
      break;
    case 'ArrowLeft':
      direction = 'left';
      break;
    case 'ArrowRight':
      direction = 'right';
      break;
  }
});
  function goFullScreen() {
  let elem = document.documentElement;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.mozRequestFullScreen) {
    elem.mozRequestFullScreen();
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) {
    elem.msRequestFullscreen();
  }
}

document.addEventListener('DOMContentLoaded', function() {
  goFullScreen();
});


// Wrap the gameLoop() call in a try-catch block to catch any errors
try {
  gameLoop();
} catch (error) {
  console.error("An error occurred in the game loop:", error);
}
  </script>
</body>
</html>
